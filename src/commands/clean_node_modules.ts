/// <reference path="../type_definitions/rimraf.d.ts" />
import * as fs from 'fs';
import * as path from 'path';
import * as rimraf from 'rimraf';

import { ICommand } from '../ICommand';
import { IArgs } from '../IArgs';
import { DFS, IVisitor, IExpandSearch } from '../helpers/GraphTraverse';
import * as fse from '../helpers/FileSystem';


export class Rm implements ICommand {

	get usage() {
		return 'clean_node_modules';
	}

	get summary() {
		return "Search and removes any node modules folder";
	}

	public canExecute(args: IArgs): boolean {
		return true;
	}

	public execute(args: IArgs): void {

		let start_directory: fse.IFileSystemInfo = {
			path: process.cwd(),
			stat: fs.statSync(process.cwd())
		};

		DFS(start_directory,
			<IVisitor<fse.IFileSystemInfo>>this.removeFolder,
			<IExpandSearch<fse.IFileSystemInfo>>this.expandSearch);
	}

	private removeFolder(file_system_info: fse.IFileSystemInfo) {

		let file_system = fse.parsePath(file_system_info.path);
		if (file_system_info.stat.isDirectory() && file_system.name === 'node_modules') {
			rimraf.sync(file_system_info.path);
		}
	}

	private expandSearch(file_system_info: fse.IFileSystemInfo) {

		let result: fse.IFileSystemInfo[] = [];
		try {
			fs.readdirSync(file_system_info.path).forEach(file_name => {
				let file_system_path = path.join(file_system_info.path, file_name);
				let file_system_stat = fs.statSync(file_system_path);
				if (file_system_stat.isDirectory()) {
					result.push({ path: file_system_path, stat: file_system_stat });
				}
			});
		} catch (ex) { }
		return result;
	}
}